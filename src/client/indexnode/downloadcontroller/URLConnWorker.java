package client.indexnode.downloadcontroller;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.RandomAccessFile;
import java.net.HttpURLConnection;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.concurrent.ExecutorService;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import common.FS2Constants;
import common.FS2Filter;
import common.HttpUtil;
import common.Logger;

import client.indexnode.downloadcontroller.DownloadChunk.Status;
import client.indexnode.downloadcontroller.DownloadQueue.DownloadDirectory;
import client.shareserver.ThrottledInputStream;

/**
 * The first multipart implementation of a download worker.
 * It uses URLConnections to build the connections to the remote host.
 * 
 * This may need to be enhanced with a less broken http connection provider.
 * 
 * @author gary
 */
public class URLConnWorker extends DownloadWorker {
	
	RandomAccessFile onDisk;
	File saveAs;
	File progressFile;
	ArrayList<ChunkWorker> activeChunks = new ArrayList<ChunkWorker>();
	
	/**
	 * This pattern is intended to match the content-range header generated by the HttpUtil sendFileOnly method:
	 * String crh = "bytes "+newPosition+"-"+((newRemaining+newPosition)-1)+"/"+newRemaining;
	 */
	public final Pattern contentRangePattern = Pattern.compile("bytes (\\d+)-(\\d+)/(\\d+)");
	private class ChunkWorker implements Runnable {
		DownloadChunk chunk;
		volatile Thread thread;
		volatile boolean mustShutdown = false;
		
		public ChunkWorker(DownloadChunk chunk, ExecutorService pool) {
			this.chunk = chunk;
			
			//setup the chunk's transients.
			chunk.chunkTracker = info.fileProgress.getNewChild();
			chunk.setTrackerExpectedMaximum();
			chunk.status = Status.CONNECTING;
			
			//submit this chunk to the threadpool supplied.
			pool.submit(this);
		}
		
		@Override
		public void run() {
			thread = Thread.currentThread();
			boolean firstSeek = true;
			//Actually try to download the item, this either works (download is active), fails (not found, not contactable, etc), or is queued.
			try {
				dispatch.events.chunkStarted(chunk);
			} catch (InterruptedException e) {
				Logger.log("Download '"+chunk.getOwner().getFile().getName()+"'cancelled/interrupted before it even started.");
			} catch (Exception e) {
				Logger.warn("chunkStarted event dispatch: "+e);
				e.printStackTrace();
			}
			InputStream instream = null;
			try {
				try {
					while (instream==null) {
						if (mustShutdown) return;
						//1) get an input stream from the source.
						//  --this depends on if secure sockets are used.
						HttpURLConnection conn;
						if (dispatch.controller.ssvr.getIndexNodeCommunicator().noPeersAreSecure()) {
							//use insecure sockets as there is no need for TLS when all our peers are connected via insecure indexnode.
							// using plain sockets will decrease CPU load.
							conn = (HttpURLConnection) chunk.source.location.openConnection();
						} else {
							//uh oh! SSL needed:
							conn = (HttpURLConnection) FS2Filter.getFS2SecureURL(chunk.source.location).openConnection();
							chunk.secure = true;
							//In future a secret token supplied by the indexnode might be needed here as the remote peer doesn't have any guarantees that we didn't just guess the file name.
							// the secret token would probably change on a client session basis and would help as guessing the token would be O(2^63) but guessing filenames would probably be a lot easier
							// for example: https://blah:41235/shares/music/iTunes Music Library-whatever-.xml has a good chance of existing and the DH_anon does not guarantee MITM-proofiness.
							//TODO: send a secret token if supplied by the indexnode.
						}
						
						try {
							dispatch.controller.ssvr.getFS2Filter().fs2FixupURLConnectionForClient(conn, 0l); //token is meaningless for a client-client transfer.
							HttpUtil.setRequestRange(conn, chunk.position, chunk.endByte);
							
							int responseCode = conn.getResponseCode();
							
							if (responseCode==200 && chunk.isWholeFile()) { //200 is only good if we wanted the entire file:
								instream=conn.getInputStream();
							} else if (responseCode==206) { //206: partial content is only good if the content range header is what we expected:
								String crh = conn.getHeaderField("Content-Range");
								Matcher matcher = contentRangePattern.matcher(crh);
								if (crh==null ||  															//CRH must exist.
									!matcher.matches() ||													//Must match the regex.
									!(Long.parseLong(matcher.group(1))==chunk.position) ||					//the position must be the one we requested.
									!(Long.parseLong(matcher.group(2))==chunk.endByte) ||					//the last byte in the range must match
									!(Long.parseLong(matcher.group(3))==(chunk.endByte-chunk.position)+1)	//our arithmetic about how many bytes to transfer must agree
									) {
									Logger.warn("Unable to download from: "+chunk.source.peerAlias+", "+chunk.source.location+" response:" +responseCode+" content range: "+crh+", did not match expectations.");
									info.error = true;
									info.errorDescription = "remote peer ("+chunk.source.peerAlias+") isn't supplying the correct bytes to us.";
									return;
								} else {
									instream = conn.getInputStream();
								}
							} else if (responseCode==503) {
								boolean queuedAlready = chunk.status==Status.QUEUED;
								//Server busy: this means we're queued.
								chunk.status = Status.QUEUED;
								try {
									if (!queuedAlready) dispatch.events.chunkQueued(chunk);
								} catch (Exception e) {
									Logger.warn("chunkQueued event dispatch: "+e);
								}
								try {
									Thread.sleep(FS2Constants.CLIENT_TIMEDQUEUE_TOKEN_EXPIRY_INTERVAL);
								} catch (InterruptedException e) {
									if (mustShutdown) return;
								}
							} else if (responseCode==404) {
								//Server does not have the file but the indexnode thinks they do!
								info.error = true;
								info.errorDescription = "remote peer ("+chunk.source.peerAlias+") no longer shares this, get them to refresh or reconnect";
								return;
							} else {
								//download failed, not sure why.
								Logger.warn("Unable to download from: "+chunk.source.peerAlias+", "+chunk.source.location+" response:" +responseCode);
								info.error = true;
								info.errorDescription = "unknown error! response from peer: "+responseCode+", peer: "+chunk.source.peerAlias;
								return;
							}
						} finally {
							InputStream es = conn.getErrorStream();
							if (es!=null) es.close();
						}
					}
				} finally {
					if (chunk.status == Status.QUEUED) {
						try {
							dispatch.events.chunkUnqueued(chunk);
						} catch (Exception e) {
							Logger.warn("chunkUnqueued event dispatch: "+e);
						}
					}
				}
				
				//2) download from the input stream until this chunk is finished.
				//  (being here means we have an inputstream from the peer)
				
				//throttle downloads:
				instream = new ThrottledInputStream(instream, dispatch.controller.throttle);
				chunk.status = Status.DOWNLOADING;
				
				chunk.lastSplit = System.currentTimeMillis();
				chunk.lastCheckedTime = chunk.lastSplit;
				
				byte[] buffer = new byte[FS2Constants.ARBITRARY_BUFFER_SIZE];
				//download from the inputstream into the onDisk.
				while (chunk.position<=chunk.endByte) {
					//Logger.log(toString()+" pos:"+chunk.position+" tPos:"+chunk.chunkTracker.getPosition()+"endByte:"+chunk.endByte+" tEndByte"+chunk.chunkTracker.getMaximum()+"  %:"+chunk.chunkTracker.percentComplete());
					
					if (mustShutdown) return;
					int request = (int) Math.min(buffer.length, (chunk.endByte-chunk.position)+1);
					int got = instream.read(buffer, 0, request);
					if (got==-1) {
						Logger.warn("Unexpected download EOF from: "+chunk.source.peerAlias+ " on file "+chunk.owner.file.getName());
						info.error = true;
						info.errorDescription = "remote peer ("+chunk.source.peerAlias+") didn't supply enough bytes. Maybe they just disconnected or the file is in use on their end?";
						return; //TRANSFER ENDED! this isn't a problem, as this chunk will just get re-dispatched in the future.
					}

					if (mustShutdown) return;
					
					//as some operating systems (*cough* windows) don't have sparse files enabled by default, so we should inform the user when we are likely allocating grand amounts of zeros...(grumble)
					if (firstSeek) {
						chunk.status=Status.ALLOCATING;
						dispatch.controller.chunkChanged(chunk);
					}
					//write the recieved bytes to the file:
					synchronized (URLConnWorker.this) {
						onDisk.seek(chunk.position);  //this might result in serious thrashing... hope the OS caches.
						onDisk.write(buffer, 0, got);
						//now update the chunk:
						chunk.position+=got;
					}
					if (firstSeek) {
						chunk.status=Status.DOWNLOADING;
						dispatch.controller.chunkChanged(chunk);
						firstSeek = false;
					}
					chunk.chunkTracker.progress(got);
					try {
						dispatch.events.chunkTransfer(chunk, got);
					} catch (Exception e) {
						Logger.warn("chunkTransfer event dispatch: "+e);
					}
					info.error = false; //reset error condition if any chunk got here.
				}
				
				//chunk complete! :o
				synchronized (URLConnWorker.this) {
					//Check to see if the whole file is complete, if so, then close the onDisk and rename it to the target name.
					if (info.isComplete() && progressFile.exists()) {
						onDisk.close();
						if (saveAs.exists()) saveAs.delete();
						if (!progressFile.renameTo(saveAs)) {
							Logger.severe("A download could not be renamed to "+saveAs+" after completion!");
							info.error=true;
							info.errorDescription="couldn't be renamed after downloading, retrying... Antivirus programs may be interferring.";
						}
					}
				}//now just fall out and die.
				
			} catch (IOException e) {
				Logger.warn("Unable to download: "+chunk.owner.file.getName()+", "+e);
				info.error = true;
				info.errorDescription = "can't download from: "+chunk.source.peerAlias+" because: "+e;
				//e.printStackTrace();
			}  finally {
				chunk.secure = false;
				if (instream!=null) {
					try {
						instream.close();
					} catch (IOException e) {
						Logger.warn("Couldn't close download stream: "+e);
					}
				}
				if (!mustShutdown) {
					synchronized (URLConnWorker.this) {
						activeChunks.remove(this); //we are now inactive, so remove us from the activeChunks.
					}
				}
				//clear the thread's interrupted flag (so that waiting for swing later doesn't bust us):
				if (thread.isInterrupted()) {
					try {
						synchronized (thread) {
							thread.wait(); //will throw an exception immediately.
						}
					} catch (InterruptedException e) {
						// dont care. This is here to clear the interrupted status of the thread.
					}
				}
				try {
					dispatch.events.chunkEnded(chunk); //for so many reasons it is critical that a started chunk _always_ ends.
				} catch (Exception e) {
					Logger.warn("chunkEnded event dispatch: "+e);
				}
			}
		}
		
		/**
		 * Stops any download in progress
		 */
		public void shutdown() {
			mustShutdown = true;
			Thread thCopy = thread;
			if (thCopy!=null) thCopy.interrupt();
		}
	}
	
	URLConnWorker(DownloadDispatcher dispatch, DownloadInfo info) throws IOException {
		super(dispatch, info);
		
		//Ensure the target directory exists on disk:
		File inDir = ((DownloadDirectory)info.file.parent).path;
		if (!inDir.isDirectory() && !inDir.mkdirs()) {
			throw new IOException("Download directory: '"+inDir+"' could not be created.");
		}
		
		saveAs = info.file.getFile();
		progressFile = new File(saveAs.getPath()+".incomplete");
		
		onDisk = new RandomAccessFile(progressFile, "rw");
		
		info.fileProgress = dispatch.controller.allDownload.getNewChild();
		info.fileProgress.setExpectedMaximum(info.file.size);
		info.fileProgress.setPosition(info.bytesDownloaded());
		
		//reset error condition as we're trying again:
		info.error = false;
	}

	@Override
	public synchronized void downloadChunk(DownloadChunk chunk, DownloadSource source, ExecutorService pool) {
		if (shutdown) throw new IllegalArgumentException("Can't download a chunk on a shutdown worker.");
		if (source==null) throw new IllegalArgumentException("Can't download from a null source.");
		chunk.source = source;
		activeChunks.add(new ChunkWorker(chunk, pool));
	}

	@Override
	public int getActiveChunkCount() {
		return activeChunks.size();
	}

	@Override
	public synchronized Collection<DownloadChunk> getDownloadingChunks() {
		ArrayList<DownloadChunk> ret = new ArrayList<DownloadChunk>();
		for (ChunkWorker c : activeChunks) {
			if (c.chunk.status == Status.DOWNLOADING) ret.add(c.chunk);
		}
		return ret;
	}

	@Override
	public synchronized Collection<DownloadChunk> getIncompleteInactiveChunks() {
		if (shutdown) return Collections.emptyList();
		
		//start with all chunks:
		HashSet<DownloadChunk> ret = new HashSet<DownloadChunk>(info.chunks);
		
		//remove active:
		for (ChunkWorker cw : activeChunks) {
			ret.remove(cw.chunk);
		}
		
		//remove complete:
		Iterator<DownloadChunk> ci = ret.iterator();
		while (ci.hasNext()) {
			if (ci.next().isComplete()) ci.remove();
		}
		
		return ret;
	}

	@Override
	public synchronized void killAChunk() {
		if (shutdown) throw new IllegalArgumentException("Can't kill chunks on a shutdown worker.");
		for (ChunkWorker cw : activeChunks) {  //abuse the foreach to get the first.
			cw.shutdown();
			activeChunks.remove(cw); //safe for concurrent modification as the iterator is discarded next.
			break;
		}
	}

	@Override
	public synchronized DownloadChunk splitChunk(DownloadChunk chunk) {
		if (shutdown) throw new IllegalArgumentException("Can't split chunk on a shutdown worker.");
		long inChunkNewEndByte = (chunk.endByte+chunk.startByte)/2;
		long newChunkStartByte = inChunkNewEndByte+1;
		
		//create a new chunk from the end of the resized old chunk to where the old chunk ended.
		DownloadChunk newChunk = new DownloadChunk(info);
		newChunk.startByte = newChunkStartByte;
		newChunk.endByte = chunk.endByte;
		newChunk.position = newChunk.startByte;
		info.chunks.add(newChunk); //add this new chunk to the info as per contract.
		
		//resize the inChunk:
		chunk.endByte=inChunkNewEndByte;
		chunk.setTrackerExpectedMaximum();
		chunk.lastSplit = System.currentTimeMillis();

		return newChunk;
	}
	
	private volatile boolean shutdown = false;
	
	@Override
	public synchronized void shutdown() {
		shutdown = true;
		for (ChunkWorker c : activeChunks) {
			c.shutdown();
		}
		activeChunks.clear(); //no active chunks left...
		try {
			if (onDisk!=null) {
				onDisk.close();
				onDisk=null;
			}
		} catch (IOException e) {
			Logger.warn("Unable to close download file: "+e);
			e.printStackTrace();
		}
	}
	
	@Override
	public void cancel() {
		shutdown();
		if (progressFile.exists()) progressFile.delete();
	}
	
	@Override
	public String toString() {
		return info.file.getName();
	}

	@Override
	public boolean isShutdown() {
		return shutdown;
	}

	@Override
	public synchronized boolean isSecure() {
		boolean ret = false;
		for (ChunkWorker c : activeChunks) {
			if (c.chunk.isSecure()){
				ret = true;
			} else {
				return false;
			}
		}
		return ret;
	}
	
}
